Не стоял вью, вью-роутер. Подключаем, создаем в файле app.js подключение, роутинг. Создаем компонент home, добавляем его в app. 

Бутстрап подключил тупо через CDN.

Создание миграций, сидера для titles (это навбар и первые две обрасти с текстом). Можно было сразу сделать модель и миграцию для нее, одной командой. Создание контроллера типа resourse, создание api маршрута. При загрузке компонента home загружаются титлы через марштур api с помощью axios, передаются в навбар, дальше все это отрисовывается в навбаре. 

Работа с навбаром. 

Была проблема, что не переходило по ссылке на текущую страницу с #. Оказывается, дело было в том, что router-link ставит слэш своим ссылкам по умолчанию, даже если атрибут to пустой. Пришлось переделать на обычные ссылки, и пришлось играть с классами роутер-линка, под который была написано подчеркивание активных ссылок. 

думал, как сделать, чтобы по нажатию на ссылки навбара мы переходили на id страницы, притом чтобы не закрывалось самим навбаром часть id. так и не знаю как сделать, но за это автоматом отвечает библиотека animate scroll. уж не знаю, как там она стыкуется с навбаром, который кажется я сам верстал (или основа на бутстрапе, а я изменял) - но после подключения библиотеки заработало. смотри файл main.js

а вот подчеркивание ссылок в зависимости от места на странице - сделано мною как костыль, тупо от положения на странице, жестко привязано, код огромный. как правильно - не знаю. смотри Navbar.vue.

валидация сервера эта опять перекидывала на начальную страницу, хотя # стоял... В чистом html все работает. Решилось так: в blade шаблоне сделал id прямо для компонента contact, а форму отправил на этот id. все заработало. Наверно мешало то, что айди внутри компонентов на что-то другое завязаны. Но это странно, потому что отключая файл main.js тоже ничего не работало. 
ааа... при этом сломался переход на ссылку контактов в навбаре, ведь форма там находится... решил тем, что сделал пустой див с айди validation и положил его в шаблон blade.



если сервер после запроса axios отвечат с ошибкой, смотри файл логов в ларавеле. 


Как можно понять, когда мы видим ошибки ларавеля на сервере и можем видеть распечатку dd(), а когда нет? Простое правило: если идет перезагрузка страницы, то увидим сервер. Если нет - как мы его увидим, если мы остаемся на фронте. Скорее всего, работает именно так. 

		Валидация на сервере и на фронте. Суть: есть вообще два варианта валидации: на сервере, который был до этого, и на фронте. Если на сервере, то после нажатия кнопки отправки формы запрос идет на сервер, там отправляется письмо, и если есть ошибки - они приходят на фронт как ошибки валидации или как сессия с успешным сообщением (смотри контроллер и welcome). если же делаем валидацию на фронтэнде, то здесь тоже два варианта: либо делать ее на фронте только, тогда при blur инпута валидируется инпут, а кнопка отправки disabled, если хоть какой-то из инпутов невалидный. Валидные все - обычная валидация на сервере. Можно сделать валидацию полностью на фронте, смысл в том, что страница не будет перезагружаться вообще, отменяется дефолтное поведение кнопки отправки, вместо него пишется фукнция, которая делает асинхронный пост запрос на адрес (я не делал api маршрут, но думаю смысл будет тот же, возможно не покажется dump, сделанный на сервере, но суть та же), на сервере этот запрос обрабатывается как надо, и если все ок, то отправляется обратно просто текст, он принимается в методе then после axios, и дальше можно положить его в нужное место шаблона. Если же в коде на сервере какая-то ошибка, то тут как я понял есть два варианта: ошибка, которая убивает скрипт, и ошибка, типа переменная не найдена. Короче, в каких-то случаях мне приходила страница ошибки ларавел, страшная красная непонятная для юзера, в каких-то - возвращалась нормальная страница и только в консоли, мол, сервер ответил со статусом такая-то ошибка. Еще: Пример отправки post через axios есть ниже, притом мы передаем просто объект. И если этот объект $request вывести в ларе через dd, то во-первых мы ничего не увидим, потому что остаемся на своей станице на фронте, а во вторых, если с сервера возвращать этот же объект на фронт, то он будет не такой сложный, как объект $request при распечатке на ларе, а будет простой наш js объект, и не важно, что именно отправлять с сервера на фронт: $request или $request->all()


Если надо менять классы в зависимости от какого-то состояния, то берем и привязываем к классу переменную, :class="", там объект, в объекте... короче смотри файл contact.vue

===============админка==================
для создания админки первым делом создаем систему аутентификации php artisan make:auth


Дилемма: делать админку так, чтобы шаблон был ларавель, а отдельные маршруты админки - вкрапливались в основной шаблон ларавель. В этом случае будет перезагрузка страницы. Так как это путь более менее понятный, решил все делать через vue, и перезагрузки не будет. 
Но: в этом случае возникла проблема: для страницы admin надо создавать новый основной шаблон, а значит там будет свой app.js элемент (или admin.js). А файл этот лежит в ресурсах, и компилируется в паблик - а где?.. настройки вебпак в ларавель?..
на самом деле эти настройки - в mix.js. Надо просто там настроить. я не заморачивался, у меня подключается просто app.js, и в зависимости от того, какой # мы обнаруживаем на странице, выполняется один либо другой код, короче, ифом разруливается. Но это можно сделать через mix.js.
То же самое касается и scss файлов. Я захотел сделать отдельный scss для админки, чтобы не путались случайно стили. В миксе это удалось сделать, НО НАДО ПЕРЕСОБИРАТЬ ПРОЕКТ ДЛЯ ЭТОГО. 
Ну и да, в каждом шаблоне лары, отцовском, надо подключат jquery елси надо, бутстрап. Возможно, они подключаются, короче надо смотреть... Но вроде на форумах пишется, что это нежелательно, лучше в одном. 

Для редактирования текста на главной странице (баннер) создана компонент AdminBannerEdit, в нем по заполнению формы отправляется axios запрос на обычный indexController в метод updateBanner, хотя по уму конечно это надо было бы сделать в api контроллере, как я понимаю. То есть, чтобы просто обновить инфу в БД - мы неправильно использовали обычный маршрут, хотя в адресной строке вообще по нему не переходили. 

Дима сказал, что на сервере валидация делается обязательно, что на фронте валидацию легко обойти. На фронте - по желанию типа, сейчас есть тенденция все делать без перезагрузки страницы. 

Короче, я красиво поубирал все лишние компоненты в админке, оставив компонент отображения определенной секции, и компонент редактирования определенной секции. Сделано так, что находясь на определенной секции, мы знаем, на какой находимся, и нажимая кнопку редактировать, мы переходим на редактирование именно нее. 

Дальше, непонятно почему, мы в адресной строке передавали id нашей секции. Этот id действительно был нужен, но зачем он в адресной строке? В файле роутов vue я ждал его как :id в адресной строке, но вот убрать его, а передавать не как параметр, а как свойство - не получалось никак. Пробовал в router-link передавать :id="title.id", а в компоненте редактирования ловить его через props - и ничего не получалось. Оказывается, надо прописывать в файле маршрутов props: true, а передавать его не :id="title.id", а как будто он обычный параметр в адресной строке:
	<router-link :to="{name: `${routeName}-edit`, params: {id: title.id}}">




Не обновлялись данные на странице, поэтому я решил не делать prevent форме, а отправить ее как обычно. Форма отправлена методом post, AdminController ее обработал, получили сообщение в admin.js, засунули его в router-view как props, и здесь (AdminFeedbacks.vue) приняли. Это так организовал я добавление отзыва: то есть с перезагрузкой страницы. Остальные действия - без перезагрузки страницы. Почему я сделал перезагрузку? Просто автоматически не обновлялись данные на странице. На самом деле можно было вызывать метод fetch по нажатию на submit формы, и метод vuex заново бы нам обновлял данные без перезагрузки. Осознай это! Этим вторым способом реализовано удаление
	


	сделать, чтобы можно было выйти из профиля. 
	восстановить html код секций about, services, contacts
